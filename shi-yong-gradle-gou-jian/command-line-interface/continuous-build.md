# 持续构建

当有任务输入改变的时候, 持续构建 (Continuous Build) 允许你自动重新执行任务.

通常情况下, 你会指定要执行的任务让 Gradle 来执行. Gradle会分析你给出的任务需要执行的所有任务集合, 按照顺序全部执行它们, 然后停下来等你的下一次指令. 持续构建则不同, 它会按照你给出的任务指令， 不断的分析任务输入是否改变, 如果改变则再次执行，除非你强制让它停下来. 比如你的任务是把 java 的源文件编译为 class 文件, 那么当java源文件改变时, 构建就会自动再次执行.

举个例子, 你可以通过下面的命令持续运行 `test` 任务以及所有依赖的任务:

```
> gradle test --continuous
```

当源代码改变或者测试的改变都会使 Gradle 自动运行 `gradle test`. 但是和该任务无关的改变 \(比如构建脚本的改变\) 将不会触发重新构建. 如果是构建逻辑的改变, 持续构建必须重新启动才会起作用.

### 结束持续构建

如果 Gradle 和一个可以交互的输入源关联起来了, 比如终端, 你可以通过按 `CTRL-D` 键来退出持续构建\(在 Windows 上, 还需要在`CTRL-D`之后按`ENTER`或`RETURN`\). 如果 Gradle 没有和任务可以互动的输入源关联 \(e.g. 比如作为一个脚本的一部分在运行\), 构建进程就必须被终止 \(e.g. 使用 `kill` 命令\). 如果构建是通过 Tooling API 执行的, 构建可以通过 Tooling API 取消机制来取消.

### 限制

持续构建是一个正在被[孵化](https://docs.gradle.org/4.6/userguide/feature_lifecycle.html)的功能. 它目前有许多问题. 将会在将来的发布里逐渐修复.

#### 构建周期

Gradle 在一个任务执行之前就会开始观测改变. 如果一个任务执行的时候更改它自己的输入, Gradle 就会检测到改变并触发一个新的构建. 如果每次这个任务执行, 输入都会被改变, 那么这个构建就会一直被重复触发下去. 如果不使用持续构建, 一个任务改变它自己的输入永远都不会认为是一种状态的更新. 

如果你的构建进入这样一种循环, 你可以追踪 Gradle 显示的变化的文件列表. 在找到文件之后, 你应该继续查找以这个文件作为输入的任务. 在许多情况下, 这非常好找 \(比如, 一个 Java 文件被 `compileJava` 任务编译\). 在其它的情况下, 你可以使用 `--info` 日志来查找过期的文件.

#### Java 9 的限制

由于 Java 9 的类的进入权限限制, Gradle 不能设置一些操作系统的特殊选项:

* 在 macOS 上, Gradle 将会每 10 秒检查一次文件的改变, 而不是 2 秒.

* 在 Windows 上, Gradle 必须使用另外的文件观察器 \(就像在 Linux/Mac OS 上\), 这可能会引起在部分大项目中持续构建无法工作.

#### 性能和稳定性

JDK file watching facility 依赖于 macOS 上效率低下的文件轮询 \(see:[JDK-7133447](https://bugs.openjdk.java.net/browse/JDK-7133447)\). 在大型项目上, 这会严重延迟关于改变的通知.

另外, 观测机制可能锁死 macOS 系统上的 under_heavy_load \(see:[JDK-8079620](https://bugs.openjdk.java.net/browse/JDK-8079620)\). Gradle 就不能注意到文件的变化. 如果你碰到这种情况, 退出持续构建并重新启动.

在 Linux 上, OpenJDK 关于 file watch service 的实现有时候会错过一些文件系统时间\(see:[JDK-8145981](https://bugs.openjdk.java.net/browse/JDK-8145981)\).

#### symbolic links 的改变

* 创建或者移除一个会初始化一个构建

* 改变 symbolic link 指向的对象不会触发重新构建.

* 创建或者移除指向文件夹的 symbolic link 不会触发重新构建.

* 在 symbolic link 指向的文件夹中创建新的文件不会触发重新构建.

* 删除指向的文件不会引起重新构建.

#### 忽略构建逻辑的改变

现在的实现并没有重新计算执行序列中随后构建上的构建模型. 这意味着任务配置的改变或者一些其它的构建模型的改变都将被忽略.

